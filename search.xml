<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>符合类型：引用和指针——C++Primer(2)</title>
      <link href="/2019/09/09/2019-9-9/"/>
      <url>/2019/09/09/2019-9-9/</url>
      
        <content type="html"><![CDATA[<p>Primer的P.45-53详细介绍了两种复合类型：指针和引用 <del>头大的指针它leile</del> 好久不敲代码了，现在再重新回顾回顾。  </p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用为对象起了另外一个名字，通过将声明符写成&amp;d的形式来定义引用类型，其中d为声明的变量。<br>一旦初始化完成，引用将和它的初始值对象（引用只能绑定在对象上，而不是某个字面值或者表达式的计算结果）一直绑定在一起，所以引用必须要初始化。<br>为引用赋值，实际上就把值赋给了与引用绑定的对象。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i=1024,i2=2048;     //i与r都是int</span><br><span class="line">int &amp;r=i,r2=i2;         //r为引用，与i绑定在一起，r2为int</span><br><span class="line">int i3=1024,&amp;ri=i3;     //i3是int，ri是引用与i3绑定在一起</span><br><span class="line">int &amp;r3=i3,&amp;r4=i2;      //r3,r4均为引用</span><br></pre></td></tr></table></figure><p><strong>引用即别名：</strong> 引用并非对象，它只是为一个已存在的对象起的另外一个名字。  </p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针是<strong>指向</strong>另一种类型的符合类型。和引用类似，指针页实现了对其他对象的间接访问，但又存在很多不同：<br>1.指针本身就是一个对象，允许对指针进行赋值和拷贝，而且在指针的生命周期中可以现后指向几个不同的对象；<br>2.指针无需在定义时赋值，和其它类型一样，在块作用域内定义指针如果没有被初始化，也将拥有一个不确定的值。<br>指针存放某个对象的地址，要想获取地址需要使用取地址符（&amp;）。指针的类型要和所指向的对象严格匹配。  </p><p>指针的值（即地址）应属于以下四种状态之一：<br>1.指向一个对象。<br>2.只想紧邻对象所占空间的下一个位置。<br>3.空指针，意味着指针没有指向任何对象。<br>4.无效指针，即上述情况之外的其他值。</p><p>如果指针指向了一个对象，则允许使用解引用符（*）来访问对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int varl=42;</span><br><span class="line">int *p=varl;</span><br><span class="line">cout&lt;&lt;*p;</span><br></pre></td></tr></table></figure><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>空指针不指向任何对象，得到空指针最直接的办法就是用字面值nullptr来初始化指针，也可以用字面值0来初始化。（过去还用用名为NULL的预处理变量来给指针赋值，它的值就是0）<br><strong>建议：初始化所有指针。</strong> 访问一个未初始化的指针相当于访问一个本不存在的位置上的本不存在的对象，如果这个指针所占的内存空间又恰好有内容，而这些内容又恰好被当作某个地址，就很难分辨它到底是合法还是非法的了。<br><strong>赋值永远改变的是等号左边的对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ival=42;</span><br><span class="line">int *pi=0;      //pi被初始化，但没有指向任何对象</span><br><span class="line">pi=&amp;ival;       //pi的值被改变，现在指向了ival</span><br><span class="line">*pi=0;          //ival的制备改变，指针pi并没有变</span><br><span class="line">``` </span><br><span class="line">## void*指针</span><br><span class="line">void*是一种特殊的指针类型，它可以用于存放任意对象的地址，但是**不能直接操作void\*指针所指的对象**，因为我们不知道这个对象到底是什么类型的。</span><br><span class="line">## 其他</span><br><span class="line">### 指向指针的指针</span><br><span class="line">通过\*的个数可以区分指针的级别，即\*\*表示指向指针的指针，\***表示指向指针的指针的指针~~好绕啊~~</span><br><span class="line">### 指向指针的引用</span><br></pre></td></tr></table></figure><p>int i=42;<br>int <em>p;         \p是一个指针<br>int *&amp;r=p;      \r是一个对指针p的引用<br>r=&i;           \r引用了一个指针，这里就相当于令p指向i<br>*r=0;           \对r解引用,相当于</em>p,得到i,即令i=0<br>```<br><del>这玩意也好绕</del> 要理解r的类型到底是什么，最简单的方法就是<strong>从右往左阅读r的定义，离变量声明最进的符号对变量类型有最直接的影响。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++Primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭博客这一周遇见的一些C++上的小细节——C++Primer(1)</title>
      <link href="/2019/09/07/2019-9-7/"/>
      <url>/2019/09/07/2019-9-7/</url>
      
        <content type="html"><![CDATA[<h1 id="i-与-i的区别"><a href="#i-与-i的区别" class="headerlink" title="i++与++i的区别"></a>i++与++i的区别</h1><p>&emsp;很久之前有去查过这俩的区别，时间久了忘得差不多了，大体只记得计算顺序上有差别。在看C++primer 11页的时候正好看到了这个前缀运算符，顺便重新学习了一下。大概是如下两个区别：  </p><h2 id="1-运算开销上"><a href="#1-运算开销上" class="headerlink" title="1.运算开销上"></a>1.运算开销上</h2><p>&emsp;就运算开销来讲，i++会比++i多占用一个寄存器.<br>i++的实质是<code>esp=i;  i=esp+1;</code>会先将i存储在一个临时的寄存器中再对i进行加一操作。<br>++i的实质是<code>i=i+1;</code>直接将i+1作为一个整体进行返回。</p><h2 id="2-判断逻辑上"><a href="#2-判断逻辑上" class="headerlink" title="2.判断逻辑上"></a>2.判断逻辑上</h2><p>&emsp;i++是先进行判断后加一，++i则是先自加后判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i=0;</span><br><span class="line">j=i++;</span><br><span class="line">k=++i;</span><br></pre></td></tr></table></figure><p>上述代码执行后结果<code>i=2; j=0; k=2</code><br><strong>细节：在不影响判断逻辑的情况下使用++i占用内存更小，速度更快。</strong></p><h1 id="算数类型在64-32位系统中内存占用问题"><a href="#算数类型在64-32位系统中内存占用问题" class="headerlink" title="算数类型在64/32位系统中内存占用问题"></a>算数类型在64/32位系统中内存占用问题</h1><table><thead><tr><th align="center">system</th><th align="center">char</th><th align="center">short</th><th align="center">int</th><th align="center">long</th><th align="center">float</th><th align="center">double</th><th align="center">long long</th></tr></thead><tbody><tr><td align="center">32位</td><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">4</td><td align="center">4</td><td align="center">8</td><td align="center">8</td></tr><tr><td align="center">64位</td><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">8</td><td align="center">4</td><td align="center">8</td><td align="center">8</td></tr></tbody></table><p> -Note：单位byte，换算成位(bit)乘以8<br> 关于long的内存占用，在64位Windows上使用sizeof函数跑出来的结果和int一样占用4个字节 <del>我买了个假电脑嗷</del> ，而在64位Linux系统上是占用8个字节的。查了一些帖子说这个问题是不同的编译器用的数据模型不一样，64位Windows用的是LLP64模型，64位Linux用的是LP64。看师兄们的笔试题，<strong>一般问64位操作系统，默认按8个字节来处理的</strong></p><h1 id="指定字面类型值"><a href="#指定字面类型值" class="headerlink" title="指定字面类型值"></a>指定字面类型值</h1><p>C++Primer p.37，对字符和字符串字面值有：</p><table><thead><tr><th align="center">前缀</th><th align="center">含义</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">u</td><td align="center">Unicode 16字符</td><td align="center">char16_t</td></tr><tr><td align="center">U</td><td align="center">Unicode 32字符</td><td align="center">char32_t</td></tr><tr><td align="center">L</td><td align="center">宽字符</td><td align="center">wchat_t</td></tr><tr><td align="center">u8</td><td align="center">UTF-8</td><td align="center">char</td></tr></tbody></table><p> 整数和浮点数类型有：</p><table><thead><tr><th align="center">后缀</th><th align="center">最小匹配类型</th><th align="center">后缀</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">u/U</td><td align="center">unsigned</td><td align="center">f/F</td><td align="center">float</td></tr><tr><td align="center">l/L</td><td align="center">long</td><td align="center">l/L</td><td align="center">long double</td></tr><tr><td align="center">ll/LL</td><td align="center">long long</td><td align="center"></td><td align="center"></td></tr></tbody></table><p> <strong>细节：单引号’a’表示字符，双引号“abc”表示字符串</strong><br> 下一篇整理整理指针部分嗷</p>]]></content>
      
      
      <categories>
          
          <category> C++Primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初步建成~👏👏👏</title>
      <link href="/2019/09/07/First-article/"/>
      <url>/2019/09/07/First-article/</url>
      
        <content type="html"><![CDATA[<p>虽然中间 <del>鸽</del> 学习了一周，总算是把blog搭完了嗷。<br>顺道换了个主题感觉还不错，有空在完善完善。<br>之后开始慢慢记录了嗷。</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
